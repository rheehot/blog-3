
<!DOCTYPE html>
<html lang="en">
    

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="아내와 아들 그리고 딸밖에 모르는 남편">
    <title>
        Tag: draft - 아내와 아들 그리고 딸밖에 모르는 남편
    </title>
    <meta name="author" content="sculove">
    
    <meta name="keywords" content="frontend,javascript,developer,">
    
    
    
    <link rel="alternate" type="application/atom+xml" title="RSS" href="/blog/rss2.xml">
    
    <link rel="canonical" href="http://sculove.github.io/blog/tags/draft/">
    <script type="application/ld+json">{}</script>
    <meta name="description" content="FrontEnd 개발자. JavaScript, RxJS, Angular, React 기술 경험 블로그">
<meta name="keywords" content="frontend,javascript,developer">
<meta property="og:type" content="blog">
<meta property="og:title" content="아내와 아들 그리고 딸밖에 모르는 남편">
<meta property="og:url" content="http://sculove.github.io/blog/tags/draft/index.html">
<meta property="og:site_name" content="아내와 아들 그리고 딸밖에 모르는 남편">
<meta property="og:description" content="FrontEnd 개발자. JavaScript, RxJS, Angular, React 기술 경험 블로그">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="아내와 아들 그리고 딸밖에 모르는 남편">
<meta name="twitter:description" content="FrontEnd 개발자. JavaScript, RxJS, Angular, React 기술 경험 블로그">
    
    
    
    
    
    <meta property="og:image" content="http://sculove.github.io/blog/assets/images/sculove.jpeg">
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/blog/assets/css/all.css">
    <link rel="stylesheet" href="/blog/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/blog/assets/css/thumbs.css">
    <link rel="stylesheet" href="/blog/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-37362821-12"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-37362821-12');
    </script>


    
</head>
    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/blog/ ">아내와 아들 그리고 딸밖에 모르는 남편</a>
    </div>
    
        
            <a class="header-right-icon open-algolia-search" href="#search">
        
        
            <i class="fa fa-search fa-lg"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/blog/#about">
                    <img class="sidebar-profile-picture" src="/blog/assets/images/sculove.jpeg" alt="Author&#39;s picture">
                </a>
                <h4 class="sidebar-profile-name">sculove</h4>
                
                    <h5 class="sidebar-profile-bio"><p>아내와 아들 그리고 딸밖에 모르는 남편</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/blog/ " title="Home">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/blog/all-categories" title="Categories">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/blog/all-tags" title="Tags">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/blog/all-archives" title="Archives">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="#search" title="Search">
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="About">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/sculove" target="_blank" rel="external nofollow noopener noreferrer" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://www.facebook.com/chanuk.son" target="_blank" rel="external nofollow noopener noreferrer" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://kr.linkedin.com/in/chan-uk-son-8989ba56" target="_blank" rel="external nofollow noopener noreferrer" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="mailto:sculove@gmail.com" target="_blank" rel="external nofollow noopener noreferrer" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://sculove.github.io/blog/rss2.xml" target="_blank" rel="noopener" title="RSS">
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1" class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/blog/2018/01/18/javascriptflow/">
                            자바스크립트 비동기 처리 과정과 RxJS Scheduler
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-18T00:58:15+09:00">
	
		    Jan 18, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/blog/categories/Tech/">Tech</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>오늘 소개할 부분은 작성 중인 책의 “부록” 중 일부이다.<br>이 장에서는 RxJS Scheduler를 잘 사용하기 위해서 이해해야할 <code>자바스크립트 비동기 처리 과정</code>을 살펴본다.</p>
<p>RxJS를 모르는 사람이라도 <code>자바스크립트의 비동기 처리과정</code>을 이해하면 자바스크립트를 개발하는데 정말 많은 도움을 준다.<br>더 자세한 내용은 다음 URL을 참고하여 꼭! 읽어보기 바란다</p>
<h4 id="참고-URL"><a href="#참고-URL" class="headerlink" title="참고 URL"></a>참고 URL</h4><ul>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="external nofollow noopener noreferrer" target="_blank">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></li>
<li><a href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" rel="external nofollow noopener noreferrer" target="_blank">https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a></li>
<li><a href="https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/</a></li>
</ul>
<hr>
<h1 id="부록-RxJS-Scheduler와-자바스크립트-비동기-처리-과정의-이해"><a href="#부록-RxJS-Scheduler와-자바스크립트-비동기-처리-과정의-이해" class="headerlink" title="부록. RxJS Scheduler와 자바스크립트 비동기 처리 과정의 이해"></a>부록. RxJS Scheduler와 자바스크립트 비동기 처리 과정의 이해</h1><p>RxJS Scheduler는 RxJS에서 자바스크립트의 비동기 작업을 효과적으로 처리할수 있도록 도와주는 역할을 한다.<br>따라서, RxJS Scheduler를 잘 활용하기 위해서는 기본적으로 <code>자바스크립트 엔진이 어떻게 비동기 작업을 처리</code>하는 지를 알면 RxJS Scheduler를 사용하는데 많은 도움이 된다.</p>
<p>이 장에서는 자바스크립트 엔진이 어떻게 비동기 작업을 처리하는 지를 살펴보고, 각 비동기 작업에 해당되는 RxJS scheduler는 어떤 것이 있는지 살펴보기로 하자.</p>
                    
                        <a href="/blog/2018/01/18/javascriptflow/" class="postShorten-excerpt_link link">
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/blog/2017/10/07/rxjsbook4/">
                            RxJS란 무엇인가?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-10-07T15:09:27+09:00">
	
		    Oct 07, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/blog/categories/Tech/">Tech</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>오늘 소개할 부분은 작성 중인 책 2부의 개론에 해당하는 내용이다.<br>이 장을 통해 <code>RxJS의 개발과정의 큰 그림</code>을 다시한번 살펴보기 바란다</p>
<hr>
<p>1부에서는 RxJS의 본질을 알아가기 위해 RxJS가 고민했던 문제들을 살펴보았다. 2부에서부터는 RxJS 라이브러리에 대해 자세히 알아보자. 이 장을 통해서는 RxJS로 간단한 소스를 구현해보면서 RxJS의 사용법을 익혀보도록 하자.</p>
<h2 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h2><p>RxJS의 공식 사이트에서는 RxJS에 대해 다음과 같이 정의하고 있다.</p>
<blockquote>
<p>RxJS is a library for composing asynchronous and event-based programs by using observable sequences.<br>RxJS는 Observable를 사용하여 비동기 및 이벤트 기반 프로그램을 작성하기 위한 라이브러리이다.</p>
</blockquote>
<p>1부에서 필자가 정의한 <code>범용적인 데이터 플로우 솔루션</code>을 지향하는 라이브러리의 국소적인 표현이라고 할수 있다. 특이한 것은 공식 홈페이지에는 RxJS에 대해 <code>이벤트용 lodash 정도라고 생각해라</code>라는 말도 있다.</p>
<blockquote>
<p>Think of RxJS as Lodash for events.</p>
</blockquote>
<p>앞의 용어가 RxJS의 철학에 대한 정의라면, 뒤의 정의는 실제 사용에 대한 정의라고 볼수 있다.<br>RxJS가 어렵다면 지금은 그냥 <code>비동기 Array/Collection 데이터</code>를 다루는 라이브러리 정도로 생각하고 접근해보자.</p>
                    
                        <a href="/blog/2017/10/07/rxjsbook4/" class="postShorten-excerpt_link link">
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/blog/2017/07/26/rxjsbook3/">
                            RxJS가 해결하려고했던 문제3 - 로직 처리의 오류
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-07-26T01:55:25+09:00">
	
		    Jul 26, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/blog/categories/Tech/">Tech</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>오늘 소개할 부분은<br>웹어플리케이션 개발시 발생할 수 있는 <code>로직 오류에 대한 문제</code>를 RxJS는 어떻게 접근했는지에 대한 이야기이다.</p>
<hr>
<h3 id="웹어플리케이션의-로직"><a href="#웹어플리케이션의-로직" class="headerlink" title="웹어플리케이션의 로직"></a>웹어플리케이션의 로직</h3><p>웹어플리케이션은 로직에 근거하여 전달받은 입력값을 이용하여 새로운 결과를 반환하거나 표현한다.<br>여기서 로직은 산술적인 로직이 될 수 있고 비즈니스적인 로직이 될수 있다. 또는 if문과 같이 간단한 프로그램의 흐름을 담당하는 부분일 수도 있다.</p>
<p>화면에 사용자 정보를 표현하는 UI 작성하는 예를 생각해보자. (예제에서 사용하는 API는 스타워즈 등장인물을 조회한다)<br>DB로부터 조회한 사용자 목록 데이터가 입력값이라면 이 값을 바탕으로 우리는 다양한 처리를 한다.</p>
<ul>
<li>성별이 “남”과 “여”인 사용자만 추출한다 (스타워즈 등장인물은 로봇과 같이 성별이 없는 사용자도 있다)</li>
<li>사용자의 이름, 키, 몸무게를 표시한다.</li>
<li>사용자의 성별에 맞게 아이콘을 화면에 표시한다.</li>
<li>사용자의 표준 체중을 계산하여 표시한다.<blockquote>
<p>BROCA 방식</p>
<ul>
<li>남자 표준체중 = (키 - 100) × 0.9</li>
<li>여자 표준체중 = (키 - 105) × 0.9</li>
</ul>
<p>BMI 방식</p>
<ul>
<li>남자 표준체중 = 키/100 _ 키/100 _ 22</li>
<li>여자 표준체중 = 키/100 _ 키/100 _ 21</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> jsonData = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"users"</span>).innerHTML = process(jsonData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"http://swapi.co/api/people/"</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터를 처리하는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> html = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> user <span class="keyword">of</span> people.results) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/male|female/</span>.test(user.gender)) &#123;</span><br><span class="line">      <span class="keyword">let</span> broca;</span><br><span class="line">      <span class="keyword">let</span> bmi;</span><br><span class="line">      <span class="keyword">if</span> (user.gender == <span class="string">"male"</span>) &#123;</span><br><span class="line">        broca = (user.height - <span class="number">100</span> * <span class="number">0.9</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">        bmi = ((((user.height / <span class="number">100</span>) * user.height) / <span class="number">100</span>) * <span class="number">22</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        broca = (user.height - <span class="number">100</span> * <span class="number">0.9</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">        bmi = ((((user.height / <span class="number">100</span>) * user.height) / <span class="number">100</span>) * <span class="number">21</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> obesityUsingBroca = (((user.mass - broca) / broca) * <span class="number">100</span>).toFixed(</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> obesityUsingBmi = (((user.mass - bmi) / bmi) * <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      html.push(<span class="string">`&lt;li class='card'&gt;</span></span><br><span class="line"><span class="string">			  &lt;dl&gt;</span></span><br><span class="line"><span class="string">			      &lt;dt&gt;<span class="subst">$&#123;user.name&#125;</span> &lt;i class="fa fa-<span class="subst">$&#123;user.gender&#125;</span>"&gt;&lt;/i&gt;&lt;/dt&gt;</span></span><br><span class="line"><span class="string">			      &lt;dd&gt;&lt;span&gt;키 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.height&#125;</span> cm&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			      &lt;dd&gt;&lt;span&gt;몸무게: &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.mass&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			      &lt;dd&gt;&lt;span&gt;BROCA 표준체중 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;broca&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			      &lt;dd&gt;&lt;span&gt;BROCA 비만도 : <span class="subst">$&#123;obesityUsingBroca&#125;</span>&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			      &lt;dd&gt;&lt;span&gt;BMI 표준체중 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;bmi&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			      &lt;dd&gt;&lt;span&gt;BMI 비만도 : <span class="subst">$&#123;obesityUsingBmi&#125;</span>&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			  &lt;/dl&gt;</span></span><br><span class="line"><span class="string">		      &lt;/li&gt;`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> html.join(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/blog/2017/07/26/rxjsbook3/userscreenshot.png">

<p>원래 조회했던 데이터는 온데 간데 없고 그 데이터로부터 생산된 새로운 정보들을 사용하고 있다.<br>위 예제는 사용자 체중과 키를 이용하여 성별에 따라 비만도 값을 계산하고 성별 아이콘을 화면에 표시한다.</p>
<p>우리는 알게 모르게 데이터를 추출하고 변환하는 작업을 빈번하게 하고 있다.<br>복수 데이터를 처리하기 위해서는 반복문을 사용하고, 상황에 따라 데이터를 추출하거나 접근하기 위해서 분기문을 사용한다.<br>또한, 상황을 기억하거나 추출된 정보를 임시로 기억하기 위해서 변수를 사용한다.</p>
<h3 id="로직의-복잡성-그리고-오류"><a href="#로직의-복잡성-그리고-오류" class="headerlink" title="로직의 복잡성 그리고 오류"></a>로직의 복잡성 그리고 오류</h3><p>반복문과 분기문 그리고 변수는 우리 코드를 복잡하게 만든다. 반복문은 우리 코드의 가독성을 떨어뜨리고 분기문은 우리가 확인해야할 프로그램의 흐름을 여러 개로 만든다. 더군다나 우리가 기억해 놓은 변수의 값은 누군가에 의해 변경될 수 있다. 변수의 값이 변하면 우리가 의도했던대로 흐름으로 프로그램이 동작하지 않을 수 있다.<br>이렇게 반복문과 분기문 그리고 변수는 우리 코드의 복잡도를 높이고 가독성을 떨어뜨리고, 결국에는 오류의 발생 빈도를 높인다.</p>
<h4 id="반복문과-분기문"><a href="#반복문과-분기문" class="headerlink" title="반복문과 분기문"></a>반복문과 분기문</h4><p>로직의 복잡성을 줄이는 가장 간단한 방법으로는 기능을 쪼개는 것이다. 기능별로 쪼갠다는게 단순히 구역별로 쪼개게 되면 기능의 의미를 명확하게 드러내지 못한다. 더불어 이런 코드는 재사용성을 떨어뜨린다.</p>
<p>이렇게 기능을 쪼개는 일이 쉬운 일이 아닌 이유는 코드의 대다수는 다음과 같이 로직과 반복문, 분기문의 결합으로 구성되어 있기 때문이다.</p>
<img src="/blog/2017/07/26/rxjsbook3/logic.png">

<p>코드에서 반복문과 분기문을 모두 제거한다는 것은 사실상 불가능하다. 하지만 기능 단위로 분리 할 수 있다면 기능을 추상화 할 수 있고, 이로 인해 로직의 복잡성을 줄일 수 있다.</p>
<h4 id="변수는-오류의-시작"><a href="#변수는-오류의-시작" class="headerlink" title="변수는 오류의 시작"></a>변수는 오류의 시작</h4><p>변수를 사용한다는 의미는 오류를 발생시킬 수 있는 확률을 높일 수 있다. 변수는 변경될 수 있는 값이기 때문에 유용하다. 반면, 의도치 않게 이 값이 바뀔 경우에 우리는 오류에 직면하게 된다.<br>브라우저 환경의 자바스크립트에서는 싱글 쓰레드 구조이기 때문에 Mutil Thread의 사용으로 인한 동시성 문제는 자주 발생하지 않는다. 하지만 DOM에 등록된 이벤트 핸들러로 인해 변수의 값이 변경되거나 비동기 행위로 인해 외부로 노출된 변수의 값들이 변경 될 수 있다.</p>
<blockquote>
<p>WebWorker와 같은 기술 스펙을 사용하면 Mutil Thread 기술을 사용할 수 있지만 브라우저는 기본적으로 하나의 메인 스레드에서 모든 작업이 이루어 진다.</p>
</blockquote>
<p>따라서, 우리는 변수의 노출 범위를 제한하거나 제거함으로써 변수의 값이 외부에 의해 변경되지 않고 개발자의 의도에 따라 정확하게 변경될 수 있도록 보장하여만 한다.</p>
<h3 id="자바스크립트의-솔루션"><a href="#자바스크립트의-솔루션" class="headerlink" title="자바스크립트의 솔루션"></a>자바스크립트의 솔루션</h3><p>다행히도 자바스크립트는 이런 면에서는 꽤나 훌륭한 솔루션을 제공하고 있다.<br>함수형 프로그래밍의 특성을 가진 자바스크립트 함수를 이용하면 실제 로직과 상관이 없는 반복문, 분기문을 분리할 수 있다. 더불어 변수 또한 제거해 나갈 수 있다.<br>이렇게 함으로써 로직의 의미를 더욱 명확히 할 수 있으며 재사용성을 더욱 높일 수 있다.</p>
<blockquote>
<p>자바스크립트 함수는 일급객체이다.<br>일급 객체(First-class object)는 다음과 같은 특성을 가지고 있다.</p>
<ul>
<li>변수 혹은 데이터 구조에 저장할 수 있다<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> savedFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>파라미터로 전달할 수 있다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">f, value</span>) </span>&#123;&#125;;</span><br><span class="line"> foo(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"함수를 파라미터로 전달 할 수 있다"</span>);</span><br><span class="line"> &#125;, <span class="string">"값"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>반환값으로 사용할 수 있다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"함수를 반환할 수 있다"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="로직의-분리"><a href="#로직의-분리" class="headerlink" title="로직의 분리"></a>로직의 분리</h4><p>앞의 process 함수를 기능 단위의 로직과 반복문, 분기문으로 분리해보자.<br>process 함수는 다음과 같은 구조로 되어 있다.</p>
<img src="/blog/2017/07/26/rxjsbook3/advance_logic.png">

<p>여기에서 우리의 주요 관심사는 성별에 따라 비만도를 구하는 로직과 사용자별 HTML을 만드는 로직이다.<br>이 부분을 별도의 함수로 만들어보자.</p>
<p>표준 체중과 비만도를 계산하는 함수는 height, mass, gender을 입력값으로 받아서 BROCA와 BMI 방식의 비만도와 표준 체중을 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 표준 체중과 비만도를 계산하는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logic</span>(<span class="params">height, mass, gender</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> broca = (height - (gender === <span class="string">"male"</span> ? <span class="number">100</span> : <span class="number">105</span>)) * <span class="number">0.9</span>;</span><br><span class="line">	<span class="keyword">let</span> bmi = height / <span class="number">100</span> * height / <span class="number">100</span> * (gender === <span class="string">"male"</span> ? <span class="number">22</span> : <span class="number">21</span>);</span><br><span class="line">	<span class="keyword">if</span> (gender == <span class="string">"male"</span>) &#123;</span><br><span class="line">		broca = (height - <span class="number">100</span> * <span class="number">0.9</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">		bmi = (height / <span class="number">100</span> * height / <span class="number">100</span> * <span class="number">22</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		broca = (height - <span class="number">100</span> * <span class="number">0.9</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">		bmi = (height / <span class="number">100</span> * height / <span class="number">100</span> * <span class="number">21</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> obesityUsingBroca = ((mass - broca) / broca * <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">const</span> obesityUsingBmi = ((mass - bmi) / bmi * <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		broca,</span><br><span class="line">		bmi,</span><br><span class="line">		obesityUsingBroca,</span><br><span class="line">		obesityUsingBmi</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용자 정보별 HTML을 만드는 함수는 user 정보를 받아서 string 형태의 html을 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용자 정보를 표현하기 위해 HTML을 만드는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHtml</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;li class='card'&gt;</span></span><br><span class="line"><span class="string">		&lt;dl&gt;</span></span><br><span class="line"><span class="string">			&lt;dt&gt;<span class="subst">$&#123;user.name&#125;</span> &lt;i class="fa fa-<span class="subst">$&#123;user.gender&#125;</span>"&gt;&lt;/i&gt;&lt;/dt&gt;</span></span><br><span class="line"><span class="string">			&lt;dd&gt;&lt;span&gt;키 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.height&#125;</span> cm&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			&lt;dd&gt;&lt;span&gt;몸무게: &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.mass&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			&lt;dd&gt;&lt;span&gt;BROCA 표준체중 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.broca&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			&lt;dd&gt;&lt;span&gt;BROCA 비만도 : <span class="subst">$&#123;user.obesityUsingBroca&#125;</span>&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			&lt;dd&gt;&lt;span&gt;BMI 표준체중 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.bmi&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">			&lt;dd&gt;&lt;span&gt;BMI 비만도 : <span class="subst">$&#123;user.obesityUsingBmi&#125;</span>&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">		&lt;/dl&gt;</span></span><br><span class="line"><span class="string">	&lt;/li&gt;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>logic, makeHtml함수를 이용하면 다음과 같이 process 함수를 작성할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> html = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> user <span class="keyword">of</span> people.results) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/male|female/</span>.test(user.gender)) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = logic(user.height, user.mass, user.gender);</span><br><span class="line">      <span class="built_in">Object</span>.assign(user, result);</span><br><span class="line">      html.push(makeHtml(user));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> html.join(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>logic, makeHtml 함수를 만듦으로서 우리는 핵심 로직을 작성는데 집중할 수 있게 되었다.<br>더불어 logic, makeHtml 함수도 재사용 할 수 있는 단위 함수가 되었다.</p>
<h4 id="반복문-분기문-그리고-변수와의-이별"><a href="#반복문-분기문-그리고-변수와의-이별" class="headerlink" title="반복문, 분기문, 그리고 변수와의 이별"></a>반복문, 분기문, 그리고 변수와의 이별</h4><p>위에 개선한 process도 좋은 코드이다. 우리는 구현 로직에 더 집중할 수 있게 되었다.<br>하지만, 흐름을 제어하는 반복문과 분기문은 여전히 process에 존재한다.<br>코드가 크면 클수록 process에 존재하는 반복문과 조건문은 우리 코드의 가독성을 떨어뜨릴 것이다. 더불어 html, result 같은 변수가 여전히 존재하기 때문에 우리는 항상 오류에 노출될 것이다.</p>
<p>이번에는 ES5에서 제공하는 Array의 filter, map, reduce와 같은 고차함수(High-order function)를 이용하여 process를 개선해 보자.</p>
<blockquote>
<h3 id="고차함수-Higher-order-function"><a href="#고차함수-Higher-order-function" class="headerlink" title="고차함수 (Higher-order function)"></a>고차함수 (Higher-order function)</h3><ul>
<li>다른 함수를 인자로 받거나 그 결과로 함수를 반환하는 함수.<br>출처: wikipedia <a href="https://en.wikipedia.org/wiki/Higher-order_function" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Higher-order_function</a></li>
<li>고차 함수는 변경되는 주요 부분을 함수로 제공함으로서 동일한 패턴 내에 존재하는 문제를 손쉽게 해결할 수 있는 고급 프로그래밍 기법이다.</li>
<li>고차 함수를 이용하면 함수의 합성, 변형과 같은 작업을 손쉽게 할수 있다. 더불어 Currying, Memoization과 같은 기법도 사용할 수 있다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twice = <span class="function">(<span class="params">f, v</span>) =&gt;</span> f(f(v));</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(twice(fn, <span class="number">7</span>)); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> people.results</span><br><span class="line">	  .filter(<span class="function"><span class="params">user</span> =&gt;</span> <span class="regexp">/male|female/</span>.test(user.gender))</span><br><span class="line">		.map(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">      user,</span><br><span class="line">      logic(user.height, user.mass, user.gender)</span><br><span class="line">		))</span><br><span class="line">		.reduce(<span class="function">(<span class="params">acc, user</span>) =&gt;</span> &#123;</span><br><span class="line">			acc.push(makeHtml(user));</span><br><span class="line">			<span class="keyword">return</span> acc;</span><br><span class="line">		&#125;, [])</span><br><span class="line">		.join(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if문은 filter로 변환하고, 값을 변환해야하는 경우에는 map을 이용하고, 축적된 데이터를 반환해야하는 경우에는 reduce를 이용하였다.<br>각각의 고차함수에 전달되는 함수는 외부의 변수에 영향을 미치지도 않고, 영향을 받지도 않는 함수이다.<br>전달된 함수는 항상 같은 입력이 주어지면, 항상 같은 출력을 반환한다.<br>이런 함수를 함수형 프로그래밍에서는 <code>순수함수</code>라고 한다.</p>
<blockquote>
<p>순수함수와 함수형 프로그래밍에 대한 내용은 <code>부록. 함수형 프로그래밍 (Functional Programming)</code>을 참조하기 바란다.</p>
</blockquote>
<p>개선된 process에서는 반복문, 분기문, 변수가 존재하지 않는다.<br>핵심 로직은 분리되었고 코드의 흐름은 단일화되었다. 더불어 변수를 사용하지 않음으로서 오류의 발생 빈도도 크게 줄었다.</p>
<h2 id="RxJS는-어떻게-개선하였나"><a href="#RxJS는-어떻게-개선하였나" class="headerlink" title="RxJS는 어떻게 개선하였나?"></a>RxJS는 어떻게 개선하였나?</h2><p>RxJS 또한 ES5 Array의 고차 함수와 같은 <code>operator를 제공</code>함으로써 로직에 존재하는 분기문과 반복문, 그리고 변수를 제거하려고 하였다.</p>
<h3 id="Immutable-객체-Observable"><a href="#Immutable-객체-Observable" class="headerlink" title="Immutable 객체 Observable"></a>Immutable 객체 Observable</h3><p>ES5 Array의 고차함수들이 반환값으로 새로운 Array 객체를 반환하여 각각에 영향을 미치지 않도록 하는 것과 같이 RxJS의 operator는 항상 새로운 Observable을 반환함으로써 Array의 고차함수와 같이 <code>불변 객체 (Immutable Object)</code>를 반환한다.<br>불변 객체는 생성 후 그 상태를 바꿀 수 없는 객체이다. 불변 객체는 외부에서 값을 변경할 수 없기 때문에 불변 객체를 사용하는 것만으로도 프로그램의 복잡도가 줄어든다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> mappedArr = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr === mappedArr); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>Array와 다른점이 있다면 Array의 경우는 새로운 Array 객체 생성 작업만 하지만 Observable은 새로운 Observable를 만들고, 그 Observable이 operator를 호출한 Observable을 내부적으로 subscribe 하는 형태를 유지한다. 즉, Linked list 형태로 기존 Observable 객체와 새롭게 만든 Observable 객체를 operator로 연결하고 있다.</p>
<img src="/blog/2017/07/26/rxjsbook3/linked-observable.png" title="linked-observable">

<p>한 예로 Observable.map은 다음과 같이 구현되어 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">transformationFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> Rx.Observable(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 새로운 Observable은 현재의 Observable을 subscribe 한다.</span></span><br><span class="line">    source.subscribe(</span><br><span class="line">      <span class="comment">// 현재의 Observable에서 전달된 데이터를 변경하여 전달한다.</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        observer.next(transformationFn(x));</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        observer.error(err);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        observer.complete();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>이런 구조를 취함으로서 <code>source부터 전달된 데이터, 에러, 종료여부가 Observable의 operator들을 통해 전달되거나 변경되어 구독한 Observer에게 전달할 수 있게 된다.</code></p>
<p>앞에서 설명한 표준체중과 비만도 조회 예를 Observable로 변경해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax$ = <span class="keyword">new</span> Rx.Observable(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> jsonData = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">      <span class="comment">// user 데이터를 user 단위로 변환하여 전달</span></span><br><span class="line">      jsonData.results.forEach(<span class="function"><span class="params">v</span> =&gt;</span> observer.next(v));</span><br><span class="line">      observer.complete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, <span class="string">"http://swapi.co/api/people/"</span>);</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ajax$</span><br><span class="line">  .filter(<span class="function"><span class="params">user</span> =&gt;</span> <span class="regexp">/male|female/</span>.test(user.gender))</span><br><span class="line">  .map(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">Object</span>.assign(user, logic(user.height, user.mass, user.gender)))</span><br><span class="line">  .reduce(<span class="function">(<span class="params">acc, user</span>) =&gt;</span> &#123;</span><br><span class="line">    acc.push(makeHtml(user));</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  .subscribe(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"users"</span>).innerHTML = v;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>이전 우리가 개선한 process 소스와 큰 차이가 없다.</p>
<blockquote>
<p>원리 설명을 위해 부득이하게 사용자 리스트를 사용자로 바꿔 전달하였다.<br>일반적으로는 Ajax를 통해 전달 받은 정보를 바탕으로 operator를 적용한다.</p>
</blockquote>
<p>차이라면 다음과 같이 ajax$ Observable를 통해 전달 받은 데이터가 filter, map, reduce를 거쳐 observer에게 전달되는 구조로 되어있다는 것이다.</p>
<img src="/blog/2017/07/26/rxjsbook3/rx_process.png">

<h2 id="RxJS가-제공하는-Operator"><a href="#RxJS가-제공하는-Operator" class="headerlink" title="RxJS가 제공하는 Operator"></a>RxJS가 제공하는 Operator</h2><p>다음은 공식 홈페이지에서 제공하는 operator 목록이다.<br><a href="http://reactivex.io/rxjs/manual/overview.html#categories-of-operators" rel="external nofollow noopener noreferrer" target="_blank">http://reactivex.io/rxjs/manual/overview.html#categories-of-operators</a></p>
<table>
<thead>
<tr>
<th>카테고리</th>
<th>operator</th>
</tr>
</thead>
<tbody><tr>
<td>생성 operator</td>
<td>ajax, bindCallback, bindNodeCallback, create, defer, empty, from, fromEvent, fromEventPattern, fromPromise, generate, interval, never, of,repeat ,repeatWhen, range ,throw ,timer</td>
</tr>
<tr>
<td>변환 operator</td>
<td>buffer, bufferCount, bufferTime, bufferToggle, bufferWhen, concatMap, concatMapTo, exhaustMap, expand, groupBy, map, mapTo, mergeMap, mergeMapTo, mergeScan, pairwise, partition, pluck, scan, switchMap, switchMapTo, window, windowCount, windowTime, windowToggle, windowWhen</td>
</tr>
<tr>
<td>추출 operator</td>
<td>debounce, debounceTime, distinct, distinctKey, distinctUntilChanged, distinctUntilKeyChanged, elementAt, filter, first, ignoreElements, audit, auditTime, last, sample, sampleTime, single, skip, skipUntil, skipWhile, take, takeLast, takeUntil, takeWhile, throttle, throttleTime</td>
</tr>
<tr>
<td>결합 operator</td>
<td>combineAll, combineLatest, concat, concatAll, exhaust, forkJoin, merge, mergeAll, race, startWith, switch, withLatestFrom, zip, zipAll</td>
</tr>
<tr>
<td>멀티캐스팅 operator</td>
<td>cache, multicast, publish, publishBehavior, publishLast, publishReplay, share</td>
</tr>
<tr>
<td>에러 처리 operator</td>
<td>catch, retry, retryWhen</td>
</tr>
<tr>
<td>유틸리티 operator</td>
<td>do, delay, delayWhen, dematerialize, finally, let, materialize, observeOn, subscribeOn, timeInterval, timestamp, timeout, timeoutWith, toArray, toPromise</td>
</tr>
<tr>
<td>조건.참거짓 operator</td>
<td>defaultIfEmpty, every, find, findIndex, isEmpty</td>
</tr>
<tr>
<td>수학,누적 operator</td>
<td>count, max, min, reduce</td>
</tr>
</tbody></table>
<p>RxJS에서 제공하는 operator를 이용하면 Observable을 생성 할 수도 있고 전달된 데이터를 변환하거나 필요한 데이터만을 추출할 수 도 있다.<br>더불어 여러 개의 Observable을 합성하기도 하고, 하나의 Observable을 다른 여러개의 Observable로 나눌 수도 있다.</p>
<p>RxJS는 정말 많은 operator를 제공한다. operator의 의미에 대해 잘 아는 사람에게는 굉장히 편리하다. 반면 그 의미를 잘 알지 못하는 사람에게는 오히려 진입 장벽이 되기도 한다.<br>이 operator의 기본적인 철학은 <code>함수형 프로그래밍</code>에 그 근간을 두고 있다.<br>아마도 함수형 프로그래밍 언어를 배운 독자라면 꽤 익숙한 이름의 operator들이 있는 것 을 알 수 있다.</p>
<p>RxJS의 operator는 어휘와 같다.<br>내가 많은 단어와 문장을 알아서 사용하게 되면 나의 편의성이 증가하고 더불어 나의 품격도 높아질수 있다. 하지만, 다른 한편으로는 다른 사람이 내 말을 이해하기 어려워 할 수도 있다.<br>반면 내가 알고 있는 단어와 문장이 적다고 하더라도 의사소통이 될 정도의 단어와 문장을 사용한다면 생활하는데 부족함이 없다. 마찬가지로 RxJS의 모든 operator를 다 알 필요는 없다.<br>카테고리별로 자주쓰는 operator 몇 개를 잘 알고 적용할 수 있다면 충분히 RxJS의 장점을 극대화 할수 있다.<br>따라서, 이 책에서도 RxJS의 모든 Operator를 다루지는 않는다. 주요 카테고리별로 꼭! 알아야하는 RxJS의 Operator를 몇 개를 기준으로 설명을 할 예정이다.<br>자세한 내용은 다음 2부에서 진행하는 실제 프로젝트를 통해 조금씩 익혀나가 보자.</p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>웹어플리케이션의 로직은 반복문, 분기문, 변수에 의해 복잡도가 증가한다. 복잡도가 증가하게되면 이로 인해 코드의 가독성이 떨어지고 결국에는 오류에 직면하게 된다.<br>ES5 Array의 고차함수를 이용하면 반복문, 분기문, 변수를 로직으로부터 분리하고 제거할수 있다. 마찬가지로 RxJS는 ES5 Array의 고차함수와 같은 operator를 제공한다.<br>operator는 Immutable한 Observable를 항상 생성함으로써 외부나 내부에 영향을 미치지 않는다. 이런 구조는 오류의 발생 빈도를 낮추는 역할을 한다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/blog/2017/07/26/rxjsbook3/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/blog/2017/07/26/rxjsbook2/">
                            RxJS가 해결하려고했던 문제2 - 상태 전파 문제
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-07-26T01:51:20+09:00">
	
		    Jul 26, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/blog/categories/Tech/">Tech</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>오늘 소개할 부분은<br>웹어플리케이션 개발시 발생할 수 있는 <code>상태 전파 문제</code>를 RxJS는 어떻게 접근했는지에 대한 이야기이다.</p>
<hr>
<h2 id="웹어플리케이션의-상태"><a href="#웹어플리케이션의-상태" class="headerlink" title="웹어플리케이션의 상태"></a>웹어플리케이션의 상태</h2><p>우리가 만드는 웹어플리케이션은 하나의 큰 상태 머신이고 이를 구성하고 있는 크고 작은 단위들 또한 하나의 상태머신이다.<br>각각의 상태 머신들은 각자의 상태를 가지고 있고, 상태 머신들은 각자의 역할에 따라 서로 유기적으로 연결되어 있다.</p>
<p>A라는 작은 상태 머신의 상태값은 B의 입력값이 될수 있고, B의 상태값은 C와 D에 관련 있는 상태값 일수 있다.<br>따라서, A의 상태 값은 B로 전달되어야하고 B의 상태값은 다시 C와 D에 전달되어야만 한다.<br>이렇게 A의 상태 변화 정보가 B에 전달되어야하고 B의 상태값이 다시 C와 D에 전달되어야하는 이유는 바로 A, B, C, D 모듈간에 <code>의존성</code>이 있기 때문이다.</p>
<p>간단한 예를 들어보자.<br>사용자 정보(상태)를 System 클래스가 check() 함수에서 사용하고 있는 예제이다.<br>System과 User간에는 다음과 같은 의존성이 존재한다.</p>
<img src="/blog/2017/07/26/rxjsbook2/A-B-use.png" title="B가 A를 사용하는 구조">

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._state = &#123;</span><br><span class="line">      name: <span class="string">"손찬욱"</span>,</span><br><span class="line">      isLogin: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._state.name;</span><br><span class="line">  &#125;</span><br><span class="line">  isLogin() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._state.isLogin;</span><br><span class="line">  &#125;</span><br><span class="line">  login(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._state.name = name;</span><br><span class="line">    <span class="keyword">this</span>._state.isLogin = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  logout() &#123;</span><br><span class="line">    <span class="keyword">this</span>._state.name = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">this</span>._state.isLogin = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(user) &#123;</span><br><span class="line">    <span class="keyword">this</span>._token = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._id = <span class="string">"System"</span>;</span><br><span class="line">    <span class="keyword">this</span>._user = user;</span><br><span class="line">  &#125;</span><br><span class="line">  check() &#123;</span><br><span class="line">    <span class="keyword">const</span> username = <span class="keyword">this</span>._user.getName();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._user.isLogin()) &#123;</span><br><span class="line">      <span class="keyword">this</span>._token = [...username].reduce(<span class="function">(<span class="params">acc, v</span>) =&gt;</span> acc + v.charCodeAt(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;<span class="keyword">this</span>._id&#125;</span>] <span class="subst">$&#123;username&#125;</span> 의 토큰은 <span class="subst">$&#123;<span class="keyword">this</span>._token&#125;</span> 입니다`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._token = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;<span class="keyword">this</span>._id&#125;</span>] 로그인 되지 않았습니다`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> system = <span class="keyword">new</span> System(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// System 작업</span></span><br><span class="line">system.check(); <span class="comment">// [System] 로그인 되지 않았습니다</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User의 상태변화 발생</span></span><br><span class="line">user.login(<span class="string">"sculove"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// System 작업</span></span><br><span class="line">system.check(); <span class="comment">// [System] sculove 의 토큰은 769 입니다</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User의 상태변화 발생</span></span><br><span class="line">user.logout();</span><br><span class="line"></span><br><span class="line"><span class="comment">// System 작업</span></span><br><span class="line">system.check(); <span class="comment">// [System] 로그인 되지 않았습니다</span></span><br></pre></td></tr></table></figure>

<p>System은 User의 로그인 정보에 의해 System의 출력(상태)이 결정된다.</p>
<h2 id="웹어플리케이션의-상태변화로-인한-문제점"><a href="#웹어플리케이션의-상태변화로-인한-문제점" class="headerlink" title="웹어플리케이션의 상태변화로 인한 문제점."></a>웹어플리케이션의 상태변화로 인한 문제점.</h2><p>System과 User 코드는 굉장히 간단하면서도 훌륭한 예제이다. 하지만, 실프로젝트에서 사용된다면 많은 문제점이 발생할 수 있는 코드이다.</p>
<h3 id="첫째-User의-인터페이스가-변경되면-System도-함께-변경을-해주어야한다"><a href="#첫째-User의-인터페이스가-변경되면-System도-함께-변경을-해주어야한다" class="headerlink" title="첫째, User의 인터페이스가 변경되면, System도 함께 변경을 해주어야한다."></a>첫째, User의 인터페이스가 변경되면, System도 함께 변경을 해주어야한다.</h3><p>System에서는 user의 메소드인 getName, isLogin을 사용하고 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  check() &#123;</span><br><span class="line">    <span class="keyword">const</span> username = <span class="keyword">this</span>._user.getName();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._user.isLogin()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 작은 코드 조각이기 때문에, 크게 문제가 되지 않을수 있지만, 클래스의 크기가 커지면 커질수록 변경에 대한 영향도는 점점 커질 것이다.<br>뿐만 아니라, 지금은 System이 User를 사용하고 있는 상황이지만, 다른 클래스 A, B, C, … 등이 모두 User에 의존도를 가지고 있을 경우에는 더욱 더 변경에 대한 영향도는 커질 것이다.</p>
<h3 id="둘째-User-상태를-확인하기-위한-인터페이스에-대한-의사소통-비용이-발생한다"><a href="#둘째-User-상태를-확인하기-위한-인터페이스에-대한-의사소통-비용이-발생한다" class="headerlink" title="둘째, User 상태를 확인하기 위한 인터페이스에 대한 의사소통 비용이 발생한다."></a>둘째, User 상태를 확인하기 위한 인터페이스에 대한 의사소통 비용이 발생한다.</h3><p>User를 개발한 개발자와 User와 의존관계가 있는 class A, class B, class C,… 을 개발한 개발자 사이에는 의사소통에 따른 비용이 발생하게 된다.<br>지금은 User의 인터페이스가 getName, isLogin, login, logout 정도이지만, 인터페이스가 많아 질 경우 이에 대한 비용이 증가하게 될 것이다.</p>
<h3 id="셋째-다수의-클래스가-User에-의존-관계가-있는-경우라면-User의-변경여부를-반영하기-위해-다수의-클래스들이-직접-User의-상태를-모두-반영해야만-한다"><a href="#셋째-다수의-클래스가-User에-의존-관계가-있는-경우라면-User의-변경여부를-반영하기-위해-다수의-클래스들이-직접-User의-상태를-모두-반영해야만-한다" class="headerlink" title="셋째, 다수의 클래스가 User에 의존 관계가 있는 경우라면, User의 변경여부를 반영하기 위해 다수의 클래스들이 직접 User의 상태를 모두 반영해야만 한다."></a>셋째, 다수의 클래스가 User에 의존 관계가 있는 경우라면, User의 변경여부를 반영하기 위해 다수의 클래스들이 직접 User의 상태를 모두 반영해야만 한다.</h3><p>즉, 변경에 대한 전파가 원활하게 이루어지지 않는다.<br>이는 꽤나 번거로운 작업일 뿐만 아니라, User와 의존성이 있는 다수의 클래스들과의 의존 관계를 항상 염두에 두고 개발을 해야만 하기 때문에, 잦은 오류가 발생하기 쉽다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 상태변화 발생</span></span><br><span class="line">user.login(<span class="string">"sculove"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// User와 의존관계가 있는 classA</span></span><br><span class="line"><span class="comment">// User와 의존관계가 있는 classB</span></span><br><span class="line"><span class="comment">// User와 의존관계가 있는 classC</span></span><br><span class="line"><span class="comment">// User와 의존관계가 있는 classN ...</span></span><br><span class="line">classA.process();</span><br><span class="line">classB.process();</span><br><span class="line">classC.process();</span><br><span class="line">classN.process();</span><br></pre></td></tr></table></figure>

<h2 id="우리가-이미-알고-있는-솔루션-Observer-Pattern"><a href="#우리가-이미-알고-있는-솔루션-Observer-Pattern" class="headerlink" title="우리가 이미 알고 있는 솔루션 - Observer Pattern"></a>우리가 이미 알고 있는 솔루션 - Observer Pattern</h2><p>앞에서 이야기했던 문제점은 이미 우리가 익히 알고 있는 패턴으로 대부분 해결이 가능하다.<br>바로 <code>Observer Pattern</code>이다.<br>자 그럼 Observer Pattern에 대해 잠시 살펴보자.</p>
<h3 id="Loose-Coupling"><a href="#Loose-Coupling" class="headerlink" title="Loose Coupling"></a>Loose Coupling</h3><p>Observer Pattern에서는 상태가 변경될 대상을 Subject라고 한다. 그리고, 그 상태 변화를 관찰하는 대상을 Observer라고 한다.<br>Observer Pattern에서는 Subject와 Observer가 서로 느슨하게 연결되어 있다.<br>여기서 <code>느슨하게 연결되었다 (Loose Coupling)</code>는 의미는 Subject와 Observer가 서로 상호작용을 하지만, 서로 잘 모른다는 의미이다.<br>Subject가 Observer 에 대해서 아는 것은 Observer가 특정 인터페이스(update)를 구현한다는 것 뿐이다.<br>Observer는 언제든지 추가, 삭제할 수 있으며, 새로운 타입의 Observer를 추가하려고 해도 Subject를 변경할 필요가 전혀 없다.<br>또한, Subject와 Observer는 서로 독립적으로 사용이 가능하며, Observer 가 바뀌더라도 서로한테 영향을 미치지 않는다.</p>
<h3 id="자동-상태-전파"><a href="#자동-상태-전파" class="headerlink" title="자동 상태 전파"></a>자동 상태 전파</h3><p>기존 방식과 같이 데이터를 얻고자 하는 대상이 데이터를 직접 가져오는 방식은 매번 요청을 하여 변경 사항을 확인해야만 한다.<br>하지만 Observer Pattern은 이와 다르게 의존 관계의 대상(Subject)으로 부터 데이터를 제공 받는 방식이다.<br>전자의 경우를 <code>Pull</code> 방식이라고 후자를 <code>Push</code> 방식이라고 한다.</p>
<img src="/blog/2017/07/26/rxjsbook2/pull_push.png" title="Pull과 Push">

<p>Push 방식은 Pull 방식에 비해 상태 전파 문제를 효과적으로 처리 할 수 있다.<br>Push 방식으로 구성된 Observer Pattern은 Subject의 상태가 변경되었을 경우 관찰하는 Observer에게 자동으로 알려준다. 특히, Subject와 Observer가 1:n의 상황에서는 더욱 유효하다.<br>다수의 Observer를 Subject에 등록하기만하면 Subject의 변경사항이 등록된 다수의 Observer에게 자동으로 전달된다.<br>개발자는 데이터 변경 시점을 매번 확인할 필요도 없고 신경쓸 필요도 없다. 단지 변경되었다는 신호가 왔을 경우 처리만 해주면된다.</p>
<h3 id="인터페이스의-단일화"><a href="#인터페이스의-단일화" class="headerlink" title="인터페이스의 단일화"></a>인터페이스의 단일화</h3><p>앞에서 살펴본 바와 같이 인터페이스가 있다는 것은 많은 비용을 수반한다. 인터페이스가 증가 할때마다 개발자간의 의사소통 비용이 증가하고 변경 영향도도 커진다.<br>사실 이 문제는 인터페이스를 줄이는 것 만으로도 비용을 줄일 수 있다. 하지만 더욱 좋은 방법은 인터페이스가 있어도 없게 만드는 것이다. 어려운 이야기지만 사실 간단하다. <code>인터페이스를 특정 몇개로 통일하는 것이다.</code><br>모든 객체가 쓰는 인터페이스는 methodA, methodB, methodC 이다라고 정의하면 서로의 의사소통 비용이 줄어든다. 더불어, 변경사항이 생기더라도 영향도는 기존 보다 훨씬 작아진다.<br>Observer Pattern은 <code>Observer.update</code>만 존재하기 때문에 Subject에서는 Observer 인터페이스에 대한 별도의 비용이 존재하지 않는다.</p>
<h2 id="Observer-Pattern의-흔한-예"><a href="#Observer-Pattern의-흔한-예" class="headerlink" title="Observer Pattern의 흔한 예"></a>Observer Pattern의 흔한 예</h2><p>실제 Observer Pattern으로 작성된 예제를 통해 Observer Pattern을 이해해보자.<br>이런 Observer pattern의 가장 흔한 예로는 뉴스를 발행하는 신문사와 이를 구독하는 고객들이 있는 경우가 있다.</p>
<p>뉴스를 발행하는 신문사(Subject)는 고객들(Observer)를 등록하고, 신문이 발행될 때, 각각의 고객들에게 신문이 발행되었다고 알려준다.(notify)<br>각 고객들은 신문이 발행되었을때, 어떤 고객은 뉴스를 스크랩하거나, 어떤 고객은 뉴스를 읽기 시작한다.</p>
<p>이를 다이어그램으로 표현하면 다음과 같다.</p>
<img src="/blog/2017/07/26/rxjsbook2/observerpattern.png" title="Observer 패턴">

<p>이제 간단하게 코드로 작성해보자.</p>
<p>뉴스 정보를 저장하는 클래스를 작성해보자. 이 클래스는 뉴스 정보를 변경할 수 있는 setNews() 메소드를 제공한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPaper</span> </span>&#123;</span><br><span class="line">  setNews(news) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NewsPaper 클래스를 Subject 역할을 할수 있도록 구현해보자.<br>각각의 Observer를 등록, 삭제 할수 있는 add, remove 메소드를 추가하고,<br>상태 변경이 일어났을 때 각각 Observer의 update 메소드를 호출하는 notify 메소드를 추가하자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPaper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>._observers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    setNews(news) &#123;</span><br><span class="line">        <span class="keyword">this</span>.notify(news);</span><br><span class="line">    &#125;</span><br><span class="line">    add(observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>._observers.push(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    remove(observer) &#123;</span><br><span class="line">        <span class="keyword">let</span> idx = <span class="keyword">this</span>._observers.indexOf(observer);</span><br><span class="line">        <span class="keyword">if</span> (idx !== <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._observers.splice(idx,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    notify(news) &#123;</span><br><span class="line">        <span class="keyword">this</span>._observers.forEach( <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            v.update(news);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제는 뉴스를 구독하고자 하는 각각의 NewsScrapper와 NewsReader Obsever를 만들어보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsScrapper</span> </span>&#123;</span><br><span class="line">  update(news) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`뉴스를 스크랩하자 - <span class="subst">$&#123;news&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsReader</span> </span>&#123;</span><br><span class="line">  update(news) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`뉴스를 읽자 - <span class="subst">$&#123;news&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자 이제 Observer Pattern을 이용하여 Subject와 Observer들을 만들어 보았다.<br>잘 동작하는지 확인해보자.</p>
<p>NewsPaper에 구독을 원하는 Observer(NewsScrapper, NewsReader)를 등록하고 NewsPaper의 setNews()를 통해 뉴스의 내용을 변경해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newsPaper = <span class="keyword">new</span> NewsPaper();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독하기</span></span><br><span class="line">newsPaper.add(<span class="keyword">new</span> NewsScrapper());</span><br><span class="line">newsPaper.add(<span class="keyword">new</span> NewsReader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상태 변경</span></span><br><span class="line">newsPaper.setNews(<span class="string">"북한 미사일 발사!!!"</span>);</span><br><span class="line">newsPaper.setNews(<span class="string">"코스피 최저점 이탈!!!"</span>);</span><br><span class="line">newsPaper.setNews(<span class="string">"남북평화회담 성사"</span>);</span><br><span class="line">newsPaper.setNews(<span class="string">"남북통일"</span>);</span><br></pre></td></tr></table></figure>

<p>새로운 뉴스가 구독자들에게 잘 전달이 되는가?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">뉴스를 스크랩하자 - 북한 미사일 발사!!!</span><br><span class="line">뉴스를 읽자 - 북한 미사일 발사!!!</span><br><span class="line">뉴스를 스크랩하자 - 코스피 최저점 이탈!!!</span><br><span class="line">뉴스를 읽자 - 코스피 최저점 이탈!!!</span><br><span class="line">뉴스를 스크랩하자 - 남북평화회담 성사</span><br><span class="line">뉴스를 읽자 - 남북평화회담 성사</span><br><span class="line">뉴스를 스크랩하자 - 남북통일</span><br><span class="line">뉴스를 읽자 - 남북통일</span><br></pre></td></tr></table></figure>

<p>상태 변경이 잘 전파되고 있다.<br>좋다.</p>
<h2 id="Observer-패턴-적용-하기"><a href="#Observer-패턴-적용-하기" class="headerlink" title="Observer 패턴 적용 하기"></a>Observer 패턴 적용 하기</h2><p>Observer 패턴을 우리가 고민했던 문제의 예제에 적용해보자.<br>상태 변화를 관찰할 User를 Subject로 만들고, System을 Observer로 변경해보자.</p>
<p>Subject는 각각의 Observer를 관리하는 기능 자제가 별도로 존재하기 때문에, 이를 상위 클래스로 만들고,<br>User를 하위 클래스로 변경해보자.</p>
<p>User의 상위 클래스로 사용될 Subject를 만들어보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._observers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>._observers.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  remove(observer) &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="keyword">this</span>._observers.indexOf(observer);</span><br><span class="line">    <span class="keyword">if</span> (idx !== <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._observers.splice(idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify(status) &#123;</span><br><span class="line">    <span class="keyword">this</span>._observers.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">      v.update(status);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Subject를 User의 부모 클래스로 지정하고, Observer인 System은 User와의 의존 관계를 제거 한다.<br>check 메소드는 Subject로 부터 데이터를 전달받을 상태정보(status)를 파라미터로 받고, 메소드명을 update로 변경한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>._state = &#123;</span><br><span class="line">            name: <span class="string">"손찬욱"</span>,</span><br><span class="line">            isLogin: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._state.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    isLogin() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._state.isLogin;</span><br><span class="line">    &#125;,</span><br><span class="line">    login(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>._state.name = name;</span><br><span class="line">        <span class="keyword">this</span>._state.isLogin = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify(<span class="keyword">this</span>._state);</span><br><span class="line">    &#125;,</span><br><span class="line">    logout() &#123;</span><br><span class="line">        <span class="keyword">this</span>._state.name = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>._state.isLogin = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify(<span class="keyword">this</span>._state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>._token = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>._id = <span class="string">"System"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    update(status) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isLogin) &#123;</span><br><span class="line">            <span class="keyword">this</span>._token = <span class="built_in">Array</span>.prototype.reduce.call(</span><br><span class="line">                status.username,</span><br><span class="line">                (acc, v) =&gt; acc + v.charCodeAt(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;<span class="keyword">this</span>._id&#125;</span>] <span class="subst">$&#123;status.username&#125;</span> 의 토큰은 <span class="subst">$&#123;<span class="keyword">this</span>._token&#125;</span> 입니다`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>._token = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;<span class="keyword">this</span>._id&#125;</span>] <span class="subst">$&#123;status.username&#125;</span> 은(는) 로그인 되지 않았습니다`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> system = <span class="keyword">new</span> System();</span><br><span class="line"></span><br><span class="line">user.add(system);</span><br><span class="line"></span><br><span class="line"><span class="comment">// User의 상태변화 발생</span></span><br><span class="line">user.login(<span class="string">"sculove"</span>);</span><br><span class="line">user.logout();</span><br><span class="line">user.login(<span class="string">"crazymonlong"</span>);</span><br></pre></td></tr></table></figure>

<p>System은 생성자에서 더이상 User의 인스턴스를 받지 않는다. 기존에 비해 의존성은 느슨해졌고 변경 상태도 의존성을 가진 모든 객체에 즉시 전파가 된다.</p>
<p>Login 클래스에 생성자의 파라미터로 구분자를 받는다면, 다수의 Login 모듈을 User에 등록하여 사용할 수도 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>._id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제는 User의 add를 통해 등록만 하면, User의 상태 변화를 모두 감지할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> observer1 = <span class="keyword">new</span> System(<span class="string">"observer1"</span>);</span><br><span class="line"><span class="keyword">let</span> observer2 = <span class="keyword">new</span> System(<span class="string">"observer2"</span>);</span><br><span class="line"><span class="keyword">let</span> observer3 = <span class="keyword">new</span> System(<span class="string">"observer3"</span>);</span><br><span class="line"></span><br><span class="line">user.add(observer1);</span><br><span class="line">user.add(observer2);</span><br><span class="line">user.add(observer3);</span><br></pre></td></tr></table></figure>

<p>변경에 대한 인터페이스도 <code>update</code> 하나로 간결해졌다.</p>
<h2 id="RxJS는-무엇을-해결하고자-했는가"><a href="#RxJS는-무엇을-해결하고자-했는가" class="headerlink" title="RxJS는 무엇을 해결하고자 했는가?"></a>RxJS는 무엇을 해결하고자 했는가?</h2><p>RxJS는 상태 변화에 대한 문제를 Observer Pattern을 기반으로 해결하려고 하였다. 다만 기존 Observer Pattern에서 아쉬웠던 몇가지를 개선하였다.<br>앞에서 살펴본 <code>신문사와 구독자</code>의 예를 기준으로 살펴보자.</p>
<h3 id="RxJS가-개선하려고했던-Observer-Pattern"><a href="#RxJS가-개선하려고했던-Observer-Pattern" class="headerlink" title="RxJS가 개선하려고했던 Observer Pattern"></a>RxJS가 개선하려고했던 Observer Pattern</h3><h4 id="1-상태-변화는-언제-종료되는가"><a href="#1-상태-변화는-언제-종료되는가" class="headerlink" title="1. 상태 변화는 언제 종료되는가?"></a>1. 상태 변화는 언제 종료되는가?</h4><p>만약, 뉴스 서비스 종료로 더이상 뉴스를 전달하지 않게 되었다면 우리는 어떻게 구독자들(NewsScrapper, NewsReader)에게 이 내용을 전달할 수 있을까?<br>아마 다음과 같이 <code>뉴스서비스 종료</code>라는 특정 문자를 각 구독자들에게 보내고,<br>구독자는 <code>뉴스서비스 종료</code>라는 상태가 전달이 되면 <code>구독이 중지되었다</code>고 생각하고 별도의 처리를 해야만 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsScrapper</span> </span>&#123;</span><br><span class="line">  update(news) &#123;</span><br><span class="line">    <span class="keyword">if</span> (news === <span class="string">"뉴스서비스 종료"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"뉴스 스크랩 서비스가 종료되었음"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`뉴스를 스크랩하자 - <span class="subst">$&#123;news&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsReader</span> </span>&#123;</span><br><span class="line">  update(news) &#123;</span><br><span class="line">    <span class="keyword">if</span> (news === <span class="string">"뉴스서비스 종료"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"뉴스 읽는 서비스가 종료되었음"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`뉴스를 읽자 - <span class="subst">$&#123;news&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewsScrapper 구독</span></span><br><span class="line">newsPaper.add(<span class="keyword">new</span> NewsScrapper());</span><br><span class="line"><span class="comment">// NewsReader 구독</span></span><br><span class="line">newsPaper.add(<span class="keyword">new</span> NewsReader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상태 변경</span></span><br><span class="line">newsPaper.setNews(<span class="string">"북한 미사일 발사!!!"</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 종료시</span></span><br><span class="line">newsPaper.setNews(<span class="string">"뉴스서비스 종료"</span>);</span><br></pre></td></tr></table></figure>

<p>이는 우리가 처음에 고민했던, 의사소통 비용에 대한 문제를 완벽하게 해결하지 못한 경우라고 이야기할 수 있다.<br>Observer Pattern은 상태를 전달하는 Subject의 데이터가 언제 종료되는지를 Observer들은 알 수가 없다.<br>이를 해결하기 위해서는 위와 같이 Observer와 Subject간에 별도의 규칙을 정해야만 한다. 결국 우린 또 다른 의사소통 비용을 쏟아야만하고, 결국 이런 의사소통의 산출물로 코드에 if문을 만들어야만 한다.<br>개발자로서 꽤 찝찝하고, 아쉬운 부분이다.</p>
<h4 id="2-상태-변화에서-에러가-발생하면"><a href="#2-상태-변화에서-에러가-발생하면" class="headerlink" title="2. 상태 변화에서 에러가 발생하면?"></a>2. 상태 변화에서 에러가 발생하면?</h4><p>프로그램에서 기능이 정상 동작하는 경우가 대다수이지만 꼭 고민해야할 부분 중의 하나가 바로 에러 처리이다.<br>프로그래머가 예측한 경우에 대한 에러 일수도 있고 예측 불가능한 에러 일 수도 있다.<br>하지만, 분명한 것은 우리가 개발한 서비스는 항상 정상적인 상황에서 돌아가지만은 않는다는 것이다.</p>
<p>NewsPaper의 setNews 메소드에서 다음과 같이 에러가 발생하게 되면 어떻게 될까?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setNews(news) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"NewsPaper Error"</span>); <span class="comment">// 에러 발생.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.notify(news);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>우선, Subject 자체적으로 에러처리를 할 수 있다.<br>try-catch 문을 사용하면, 에러 발생 시 다시 한번 상태 변경을 시도 하거나, 상태 변경 작업 자체를 무시하는 등의 작업을 할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setNews(news) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"NewsPaper Error"</span>); <span class="comment">// 에러 발생.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.notify(news);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="comment">// 다시 시도~!</span></span><br><span class="line">        <span class="keyword">this</span>.notify(news);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 Subject 쪽에서 에러에 대한 처리를 별도로 하면, 등록된 Observer들은 상태 변경시 에러가 발생했는지 정상 동작했는지 모른다. 물론, 이 방법도 좋다.<br>하지만, 경우에 따라서는 등록된 Observer 쪽에서 에러 발생 여부를 인지하고, 이에 대한 별도의 처리를 해야하는 경우가 필요하다.<br>Observer 패턴은 update 인터페이스만을 통해서 Subject의 상태를 Observer에게 전달하기 때문에, 이 상황을 처리하기에는 어렵다.<br>아쉽지만, Observer 패턴은 에러 발생 여부를 Observer들에게 전달할 방법이 딱히 없다.</p>
<h4 id="3-Observer에-의해-Subject의-상태가-변경되는-경우는"><a href="#3-Observer에-의해-Subject의-상태가-변경되는-경우는" class="headerlink" title="3. Observer에 의해 Subject의 상태가 변경되는 경우는?"></a>3. Observer에 의해 Subject의 상태가 변경되는 경우는?</h4><p>신문사 기자이면서 동시에 구독자인 사람이 있는 경우라면 어떻게 될까?<br>만약 이 기자가 구독받은 기사의 내용을 조금 변경하여 다시 뉴스를 만드는 기레기 기자라면 우리는 생각보다 심각한 상황에 빠지게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriterAndReader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(newsPaper) &#123;</span><br><span class="line">    <span class="keyword">this</span>._newPaper = newsPaper;</span><br><span class="line">  &#125;</span><br><span class="line">  update(news) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`전달 받은 뉴스 - <span class="subst">$&#123;news&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>._newPaper.setNews(<span class="string">`변형된 뉴스 - <span class="subst">$&#123;news&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriterAndReader 구독</span></span><br><span class="line">newsPaper.add(<span class="keyword">new</span> WriterAndReader(newsPaper));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상태 변경</span></span><br><span class="line">newsPaper.setNews(<span class="string">"북한 미사일 발사!!!"</span>);</span><br></pre></td></tr></table></figure>

<p>뉴스는 계속 반복적으로 생성되어 결국 브라우저는 뻗게 될 것이다.<br>이와 같이 Subject를 관찰하는 Observer가 Subject의 상태를 변경하는 경우에는 우리가 예상하지 못하는 복잡한 상황에 직면하게 될 수 있다.<br>이 예는 다소 과한 면이 있지만 우리가 프로그램을 하다보면 이렇게 데이터가 양방향으로 흐르게하는 경우가 종종 있다.<br>데이터의 흐름이 양방향으로 흐르게 함으로써 편한 면도 있지만 궁극적으로는 코드의 복잡도를 증가시키는 경우가 많다.</p>
<h2 id="RxJS는-어떻게-개선하였나"><a href="#RxJS는-어떻게-개선하였나" class="headerlink" title="RxJS는 어떻게 개선하였나?"></a>RxJS는 어떻게 개선하였나?</h2><p>RxJS 역시 Observer 패턴으로 상태 전달 문제를 해결하려고 하였다.</p>
<p>우선 RxJS에 녹아 있는 Observer 패턴을 살펴보자.<br>RxJS에서 전달되는 데이터는 모두 Observable 형태로 반환된다.<br>Observable은 <code>subscribe</code> 과정 후부터 데이터를 전달받기 시작한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> click$ = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">"click"</span>);</span><br><span class="line">click$.subscribe(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>반면, Observer 패턴에서는 Subject와 Observer가 <code>add</code> 과정 후 부터 데이터를 전달받기 시작한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newsPaper = <span class="keyword">new</span> Subject();</span><br><span class="line">newsPaper.add(&#123;</span><br><span class="line">  update: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>둘의 관계는 닮았다. RxJS의 Observable은 Observer 패턴의 Suject와 닮았다.<br>그런데 Observer 패턴의 Observer에 해당하는 subscribe의 파라미터는 정작 객체가 아니라 함수이다.</p>
<p>이런 차이가 발생하게 된 배경은 RxJS가 기존 Observer 패턴의 아쉬웠던 점을 개선하고자 했기 때문이다.<br>RxJS가 개선한 Observer 패턴에 대해 살펴보도록 하자.</p>
<h3 id="RxJS가-개선한-Observer-Pattern"><a href="#RxJS가-개선한-Observer-Pattern" class="headerlink" title="RxJS가 개선한 Observer Pattern"></a>RxJS가 개선한 Observer Pattern</h3><h4 id="인터페이스의-확장"><a href="#인터페이스의-확장" class="headerlink" title="인터페이스의 확장"></a>인터페이스의 확장</h4><p>1장에서 살펴본 바와 같이 RxJS는 시간의 축으로 데이터를 보기 때문에 데이터의 연속적인 변화를 Observer에서 표현할수 있도록 기존 <code>update 메소드를 next로 바꾸었다.</code><br>또한 Observer 패턴은 종료시점, 에러시점에 대한 인터페이스가 존재하지 않기 때문에, 종료를 나타내는 <code>complete 메소드와 에러시점을 나타내는 error 메소드를 추가</code>하였다.</p>
<p>즉, Observer패턴에서는 하나의 메소드를 갖는 Observer를 사용하였다면 RxJS의 Observer는 next, complete, error의 3개 메소드를 갖는다. 그런데 객체가 아닌 왜 함수를 사용하는 것인가?<br>물론, Observable.subscribe는 다음과 같이 객체, 함수 모든 형태로든 다 전달 받을 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers$ = Rx.Observable.of([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// next, error, complete가 있는 객체를 받음</span></span><br><span class="line">numbers$.subscribe(&#123;</span><br><span class="line">  next(v) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;,</span><br><span class="line">  error(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"complete"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// next 함수만 받음</span></span><br><span class="line">numbers$.subscribe(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// next, error 함수만 받음</span></span><br><span class="line">numbers$.subscribe(</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// next, error, complete 함수를 받음</span></span><br><span class="line">numbers$.subscribe(</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e);</span><br><span class="line">  &#125;,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"complete"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>하지만, RxJS의 subscribe는 특별한 경우를 제외하고는 가급적 함수 형태를 사용한다.<br>그 이유는 객체는 상태를 가질 수 있기 때문이다.<br>객체가 상태를 가진다는 의미는 또 다른 상태 머신이 될 수 있다는 의미이기도 하다. 반면 함수는 상태가 존재하지 않는 기능만을 담당하기 때문에 상태에 관한 문제에서는 보다 자유롭다.<br>이와 관련된 내용은 3장에서 다룰 <code>로직 오류에 대한 문제</code>에서 다시 한번 다루도록 하겠다.</p>
<h4 id="Observable은-Read-only"><a href="#Observable은-Read-only" class="headerlink" title="Observable은 Read-only"></a>Observable은 Read-only</h4><p>“기자이면서 구독자인 사례”와 같이 데이터가 양방향으로 흐르는 문제를 RxJS는 구조적으로 개선하려고 하였다.<br>Observable은 subscribe를 통해 데이터를 전달할 대상(Observer)에게 데이터를 전달할 수 있지만, 반대로 전달 대상(Observer)에게는 데이터를 전달할 수 없다. Observable은 전달하는 데이터를 설정할 수 있는 그 어떤 메소드도 제공하지 않는다. Observable은 데이터를 얻거나 변경 또는 머지만 할 수있을 뿐 데이터를 생성하지는 못한다. 즉, Observable에서 전달된 데이터는 <code>Observer 한 방향으로만 흐르게 된다</code></p>


<p>이렇게한 근본적인 이유는 데이터 흐름을 단순화함으로 복잡도를 낮추고 오류 발생 빈도를 줄이기 위해서 이다.<br>물론, 데이터가 양방향으로 흐르게 되면 사용상 편리할 수는 있다. 하지만, 어플리케이션의 규모가 커지게 되면 양방향으로 흐르는 데이터의 복잡도는 통제하기 어려울 정도로 복잡해진다.</p>
<p>이러한 이유로 최근 등장한 프레임워크들은 모두 <code>단방향 데이터 흐름</code>을 지향한다.</p>
<blockquote>
<p>React와 Angular2+, Vue 모두 단방향 데이터 흐름을 지향한다.</p>
</blockquote>
<h3 id="Observable은-리액티브하다"><a href="#Observable은-리액티브하다" class="headerlink" title="Observable은 리액티브하다."></a>Observable은 리액티브하다.</h3><p>RxJS는 Observer 패턴과 마찬가지로 데이터가 발생하게되면 Observer에게 자동으로 그리고 빠르게 변경된 데이터를 전달한다.<br>이를 보고 <code>리액티브하다</code>고 이야기한다.<br>리액티브하다라는 의미를 이해하기 위해서는 우선 리액티브 프로그래밍(Reactive Programming)에 대한 정의 부터 살펴보자. 위키피디아에서는 다음과 같이 정의되어 있다.</p>
<blockquote>
<p>리액티브 프로그래밍은 데이터 흐름과 상태 변화 전파에 중점을 둔 프로그램 패러다임이다. 사용되는 프로그래밍 언어에서 데이터 흐름을 쉽게 표현할 수 있어야하며 기본 실행 모델이 변경 사항을 데이터 흐름을 통해 자동으로 전파한다는 것을 의미한다.</p>
<p>출처 : <a href="https://en.wikipedia.org/wiki/Reactive_programming" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Reactive_programming</a></p>
</blockquote>
<p>위 정의에서 가장 핵심이 되는 단어는 <code>데이터 흐름</code>과 <code>자동으로 전파</code>이다. 즉, 상태 변화의 흐름이 자동으로 전파되는 것을 <code>리액티브</code>하다고 이야기한다.</p>
<p><code>리액티브</code>의 가장 흔하게 드는 예로 ‘엑셀’을 이야기할 수 있다.</p>


<p>A열의 값과 B열의 값의 합을 나타내는 C열은 A열이나 B열의 값이 변화되는 경우 자동으로 C열의 값이 변경된다.<br>이렇게 A나 B열의 변경사항이 데이터 흐름을 통해 자동으로 C열에 전파되도록 구조화하는 프로그래밍의 패러다임을 <code>리액티브 프로그래밍</code>이라고 한다.</p>
<p>이 말은 앞에서 살펴 보았던 상태 변화에 대한 우리의 고민들과 일맥 상통한다고 이야기할 수 있다.<br>이런 고민의 해결책이 Observer 패턴이고, RxJS는 이런 Observer 패턴을 개선하여 어플리케이션에서 발생하는 모든 데이터를 리액티브하게 전달 할 수 있게 해준다. 따라서, RxJS는 <code>리액티브 프로그래밍(Reactive Programming)</code>을 지향하는 라이브러리이다.</p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>이 장에서는 웹어플리케이션의 상태가 어떻게 전파되는지를 살펴 봄으로써 상태 전파로 인해 발생할 수 있는 문제점을 살펴보았다. 또한, 이러한 문제를 효과적으로 해결했던 Observer 패턴에 대해서도 살펴보았다.<br>Observer 패턴은 느슨하게 연결되어 Subject와 Observer간의 의존도를 줄였으며, Push 방식으로 데이터를 전파함으로써 상태 전파에 대한 많은 문제를 해결했다.<br>RxJS에서는 이런 Observer 패턴을 개선하여 상태 전파 문제를 해결하려고 하였다.<br>에러상황과 종료상황에 대한 인터페이스를 확장하였고, 데이터를 단방향으로 흐를 수 있도록 개선함으로써 코드의 복잡도를 낮추었다. 이런 결과 RxJS는 궁극적으로 Reactive Programming을 지향하는 라이브러리가 되었다.</p>
<p>다음장에서는 RxJS가 고민한 로직 오류에 대해 살펴보기로 하자.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/blog/2017/07/26/rxjsbook2/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/blog/2017/06/30/rxjsbook1/">
                            RxJS가 해결하려고했던 문제1 - 입력 데이터의 오류
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-06-30T05:59:51+09:00">
	
		    Jun 30, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/blog/categories/Tech/">Tech</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>몇일 전에 요즘 내가 쓰고 있는 책의 초안을 일부를 공개하기로 셀프 선언한 이후, 사실 너무 바빴다 ㅠㅠ<br>1부 탈고일이 좀 남았지만… 마음이 급하다.<br>지인과는 과감히 탕수육 내기도 했으니. 더 급하다.</p>
<p>처음이니깐 간단히 책소개만 해보면.</p>
<blockquote>
<p>RxJS가 무엇을 위해 준비된 라이브러리인지에 대한 답을 구하는 책이다. 더불어 RxJS의 활용법도 학습하는 책이다. 참고로 rxjs5 기준으로 쓰고 있다</p>
<img src="/blog/2017/06/30/rxjsbook1/rxjs.png">
</blockquote>
<p>오늘 소개할 부분은<br>웹어플리케이션 개발시 발생할 수 있는 <code>입력 오류</code>를 RxJS는 어떻게 접근했는지에 대한 이야기이다.</p>
<hr>
<h2 id="웹어플리케이션의-입력-데이터"><a href="#웹어플리케이션의-입력-데이터" class="headerlink" title="웹어플리케이션의 입력 데이터"></a>웹어플리케이션의 입력 데이터</h2><p>웹어플리케이션의 동작 과정을 되돌아보면 사실 몇 개의 큰 과정으로 나눌 수 있다.</p>
<p>간단한 게시판을 예로 생각해보자.<br>게시판은 서버에 저장된 글을 보여주는 목록화면과 게시글의 내용을 보여주는 상세화면으로 구성되어 있다.<br>서버로부터 저장된 글에 대한 정보를 받고, 받은 정보를 바탕으로 화면과 관련된 UI작업을 한다.<br>게시글의 종류나 카테고리를 셀렉트 박스로 표현할 수도 있고, 작성된 글의 내용 일부를 화면에 표현하기도 한다.</p>
<p>또한 사용자가 게시글을 등록. 수정하는 편집화면도 있다. 편집화면에서는 사용자가 셀렉트 박스를 선택하기도 하고, 글을 입력하기도 한다. 사용자의 입력이 잘못된 경우에는 사용자에게 메시지를 전달하기도 하기도 한다.<br>글의 작성 및 수정이 끝나면 등록한 정보를 서버에 저장한다.</p>
<p>이 과정을 <code>데이터가 흐르는 관점</code>으로 살펴보면</p>
<ul>
<li><ol>
<li>목록화면과 조회화면은 서버로부터 데이터를 불러와 브라우저에게 전달한다.</li>
</ol>
</li>
<li><ol start="2">
<li>브라우저에 전달된 정보를 브라우저의 UI객체에 전달한다.</li>
</ol>
</li>
<li><ol start="3">
<li>편집화면은 브라우저 UI객체를 통해 사용자 입력정보를 전달받고 이를 다시 브라우저의 다른 UI객체나 브라우저 객체에 전달한다.</li>
</ol>
</li>
<li><ol start="4">
<li>사용자가 작성한 정보를 브라우저 UI객체나 브라우저 객체를 이용하여 서버로 전달한다.</li>
</ol>
</li>
</ul>
<p>이 과정을 다시 <code>상태머신</code> 관점에서 살펴보자.<br>1)과 2)의 과정에서 입력값은 <code>서버로부터 전달 받은 게시글 데이터</code>가 된다. 두 과정의 입력값이 동일 할지라도 입력값을 받는 브라우저와 브라우저 UI 객체는 <code>서로 다른 시점</code>에 입력값을 전달받는다.<br>예를 들어 1)과정이 Ajax로 JSON 데이터를 받아와 브라우저의 객체로 저장하는 경우라면 Ajax는 비동기(Asynchronous) 호출로 데이터를 받기 까지 시간이 걸린다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLHttpRequest에 의해 입력된 데이터</span></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Ajax를 통해 얻은 데이터를 result 변수에 저장한다.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &#123;</span></span><br><span class="line"><span class="comment">   *   list: [</span></span><br><span class="line"><span class="comment">   *      "게시글1번. 안녕하세요.",</span></span><br><span class="line"><span class="comment">   *      "게시글2번. 반갑습니다.",</span></span><br><span class="line"><span class="comment">   *      "게시글3번. RxJS에 대해 알아봐요."</span></span><br><span class="line"><span class="comment">   *   ]</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  result = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>반면, 브라우저 UI객체는 이미 브라우저에 존재하는 JSON 데이터를 받기 때문에 동기(Synchronous) 호출로 바로 결과 데이터를 얻을수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">"li"</span>)).forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Ajax의 결과인 result 변수를 이용하여 DOM에 정보를 표현한다.</span></span><br><span class="line">  v.innerText = result.list[i];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>마찬가지로 3)과 4)의 과정도 입력값은 <code>사용자의 입력</code>이 되지만, 전달된 입력값을 처리하는 시점은 상황에 따라 각각 다르다.</p>
<p>앞에서 설명한 내용을 간단히 정리하면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>과정</th>
<th>데이터</th>
<th>데이터 흐름</th>
<th>전달 시점</th>
<th>예제</th>
</tr>
</thead>
<tbody><tr>
<td>1)</td>
<td>게시글</td>
<td>서버 -&gt; 브라우저</td>
<td>비동기</td>
<td>Ajax 통신으로 JSON 데이터를 받는다.</td>
</tr>
<tr>
<td>2)</td>
<td>게시글</td>
<td>브라우저 -&gt; 브라우저 UI 객체</td>
<td>동기</td>
<td>JSON 데이터를 UI에 반영한다.</td>
</tr>
<tr>
<td>3)</td>
<td>사용자가 입력한 내용</td>
<td>사용자 -&gt; 브라우저 UI객체</td>
<td>비동기</td>
<td>&lt;textarea&gt;를 통해 사용자 입력을 받는다.</td>
</tr>
<tr>
<td>4)</td>
<td>사용자가 입력한 내용</td>
<td>브라우저 UI 객체 -&gt; 브라우저 -&gt; 서버</td>
<td>동기, 비동기</td>
<td>&lt;textarea&gt;에 있는 데이터를 JSON 객체로 저장 후, 서버로 Ajax 요청을 한다</td>
</tr>
</tbody></table>
<h2 id="입력-데이터의-전달-시점이-다양하다"><a href="#입력-데이터의-전달-시점이-다양하다" class="headerlink" title="입력 데이터의 전달 시점이 다양하다."></a>입력 데이터의 전달 시점이 다양하다.</h2><p>앞에서 살펴본 바와 같이 입력데이터가 같을지라도 실제 각 객체들 사이로 데이터가 전달되는 시점은 다르다. 어떤 상황에서는 동기(Synchronous) 방식으로 데이터를 주고 받고, 어떤 상황에서는 비동기(Asynchronous) 방식으로 데이터를 주고 받는다.<br>이런 구조는 비단 웹어플리케이션 뿐만이 아니다. 소프트웨어 전반적으로 이와 같은 상황이 발생한다.<br>이런 이유는 두 방식의 차이점을 살펴보면 보다 명확히 알수 있다.</p>
<h3 id="동기-Synchronous"><a href="#동기-Synchronous" class="headerlink" title="동기(Synchronous)"></a>동기(Synchronous)</h3><p>동기방식은 작업이 들어온 순서에 맞게 차근차근 하나씩 진행되는 것을 의미한다. 호출하는 함수가 호출되는 함수의 작업 완료를 기다린 후 그 다음을 진행하는 방식이다. 이 방식의 장점은 순차적으로 진행되기 때문에 개발이 쉽다. 반면, 처리하는 작업이 많을 경우에는 전체 작업 속도가 느려진다. 특히, 웹브라우저와 같이 단일 UI쓰레드를 사용하는 경우에는 해당 작업이 끝날때까지 브라우저는 대기하고 있어야만 한다.</p>
<img src="/blog/2017/06/30/rxjsbook1/sync.png" title="Synchronous">

<h3 id="비동기-Asynchronous"><a href="#비동기-Asynchronous" class="headerlink" title="비동기(Asynchronous)"></a>비동기(Asynchronous)</h3><p>반면, 비동기 방식은 작업이 들어온 순서에 상관없이 산발적으로 진행되는 것을 의미한다. 호출하는 함수가 호출되는 함수의 작업 완료를 기다리지 않고, 그 다음을 진행하고 호출되는 함수의 작업이 완료되면 별도의 이벤트나 callback 함수를 통해 결과를 전달하는 방식이다. 이 방식의 장점은 효과적으로 작업을 진행할 수 있다는 점이다. 설사 먼저 실행된 작업의 처리시간이 오래걸리더라도 다른 작업을 진행할 수 있다. 반면, 개발은 더욱 복잡해지고 오류 확률은 높아질 우려가 있다.</p>
<img src="/blog/2017/06/30/rxjsbook1/async.png" title="Asynchronous">

<h2 id="동기와-비동기를-함께-사용할-수-밖에-없는가"><a href="#동기와-비동기를-함께-사용할-수-밖에-없는가" class="headerlink" title="동기와 비동기를 함께 사용할 수 밖에 없는가?"></a>동기와 비동기를 함께 사용할 수 밖에 없는가?</h2><p>동기 방식은 명확한 순서를 보장하면서 코드의 흐름과 프로그램의 흐름을 동일하게 처리하는 장점이 있지만, 비동기에 비해 효과적인 작업을 할 수 없다.<br>반면, 비동기 방식은효과적으로 작업을 할 수 있지만 호출의 순서를 보장하기가 어렵다. 이를 보장하기 위해서는 우리는 많은 작업들을 추가적으로 해야만 한다.</p>
<p>그렇다면 모두 동기 방식으로 개발하면 개발 생산성도 높이고, 오류의 발생빈도도 더 낮출수 있기 때문에 다른 한편으로는 더 좋은 선택이지 않는가?</p>
<p>틀린말은 아니다. 하지만 결론부터 이야기하면 그렇게 할수가 없다.<br>기반 플래폼이 제공하는 API자체가 동기 또는 비동기 방식을 제공하고 있기 때문에 본질적으로 우리는 이 문제를 피해갈 수가 없다.<br>특히 단일 쓰레드 기반의 브라우저 환경에서는 비동기 방식을 사용하지 않으면 성능 문제를 해결할 수 없기 때문에 우리에게는 선택의 여지가 없다.</p>
<h2 id="RxJS는-어떻게-개선하였나"><a href="#RxJS는-어떻게-개선하였나" class="headerlink" title="RxJS는 어떻게 개선하였나?"></a>RxJS는 어떻게 개선하였나?</h2><p>RxJS가 주목했던 부분은 바로 이 입력 데이터에 대한 구조적 문제를 개선하고자 하였다.</p>
<p>RxJS는 이런 구조적인 문제를 개선하기 위해 <code>단 하나의 방식</code>을 사용할 수 있는 구조를 제공한다. 이런 구조의 일원화는 개발을 단순화시킨다. 이런 단순화는 결국에는 오류 발생 빈도를 낮추고, 생산성 향상을 도와준다.</p>
<p>RxJS는 동기(Synchronous)와 비동기(Asynchronous)의 차이점을 <code>시간</code>이라는 개념을 도입함으로써 해결하려고했다.</p>
<p>대표적인 비동기(Asynchronous) 처리방식인 이벤트(Event)를 살펴보자.<br>Button에서 발생하는 click 이벤트를 처리하기 위해서는 다음과 같이 버튼에 이벤트 핸들러를 등록한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(<span class="string">"click"</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// @todo</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>한번 이벤트 핸들러가 등록되면 사용자가 버튼을 눌렀을 때마다 등록된 이벤트 핸들러가 호출된다.<br>이런 과정에 <code>시간</code>이라는 개념을 도입함으로써 우리는 다른 시각을 얻을 수 있다.</p>
<p>버튼을 누르는 행위가 우리가 원하는 데이터라면 시간 축을 기준으로 이 데이터는 다음과 같은 모습을 보일 것이다.</p>
<img src="/blog/2017/06/30/rxjsbook1/async-time.png">

<p>이벤트가 아닌 동기(Synchronous) 방식인 함수호출도 <code>시간</code>이라는 개념을 도입하면 다음과 같이 표현될 수 있다.</p>
<img src="/blog/2017/06/30/rxjsbook1/sync-time.png">

<p>결국 동기와 비동기는 시간의 축으로 봤을때는 같은 형태인 것이다.<br>또한, 이런 형태는 <code>시간을 인덱스로 둔 컬렉션</code>으로 생각할 수도 있다. RxJS에서는 이를 <code>스트림(Stream)</code>이라 표현한다.</p>
<img src="/blog/2017/06/30/rxjsbook1/collection-time.png">

<p>RxJS에서는 이런 Stream을 표현하는 <code>Observable</code> 클래스를 제공한다.</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>Observable은 <code>시간을 인덱스로 둔 컬렉션을 추상화한 클래스</code>이다.<br>이 클래스는 동기나 비동기의 동작 방식으로 전달된 데이터를 <code>하나의 컬렉션</code>으로 바라볼 수 있게 해준다.<br>이렇게 함으로써 개발자는 데이터가 어떤 형태로 전달되는지에 대해 더이상 고민할 필요가 없어진다.<br>단지, Observable을 통해 데이터를 전달 받기만 하면 된다.</p>
<blockquote>
<h5 id="Observable의-표준화"><a href="#Observable의-표준화" class="headerlink" title="Observable의 표준화"></a>Observable의 표준화</h5><p>RxJS의 Observable은 Rx에서 만든 라이브러리이기도 하지만, ECMAScript에 표준으로 제안된 스펙이기도하다.<br><a href="https://github.com/tc39/proposal-observable" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/tc39/proposal-observable</a></p>
<p>이 책에서 다루는 RxJS5는 ECMAScript에 제안된 표준 스펙을 기반으로 작성된 라이브러리이다.</p>
</blockquote>
<h2 id="모든-데이터는-Observable로-만들-수-있다"><a href="#모든-데이터는-Observable로-만들-수-있다" class="headerlink" title="모든 데이터는 Observable로 만들 수 있다."></a>모든 데이터는 Observable로 만들 수 있다.</h2><p>Observble은 모든 데이터를 다룬다.</p>
<ul>
<li>키보드를 눌러서 입력된 데이터</li>
<li>마우스를 이동하거나 클릭해서 입력된 데이터</li>
<li>Ajax/fetch 요청을 통해 얻은 데이터</li>
<li>Web socket을 통해 전달된 데이터</li>
<li>Message를 통해 전달된 데이터</li>
<li>…</li>
</ul>
<p></p>
                    
                        

                    
                    
                        <p>
                            <a href="/blog/2017/06/30/rxjsbook1/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 sculove. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/blog/assets/images/sculove.jpeg" alt="Author&#39;s picture">
        
            <h4 id="about-card-name">sculove</h4>
        
            <div id="about-card-bio"><p>아내와 아들 그리고 딸밖에 모르는 남편</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>FrontEnd Developer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                대한민국/서울
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="external nofollow noopener noreferrer" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search ">
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2011/05/14/building-rich/">
                            <h3 class="media-heading">빌딩부자들</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 14, 2011
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2012/02/19/donot-speak-book/">
                            <h3 class="media-heading">뱀의 뇌에게 말을 걸지마라</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Feb 19, 2012
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2012/02/29/manager-book/">
                            <h3 class="media-heading">만약 고교야구 여자 매니저가 피터드러커를 읽는다면</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Feb 29, 2012
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2012/03/18/myjob-myhappy/">
                            <h3 class="media-heading">내가 하는 일 가슴 설레는 일</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Mar 18, 2012
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2013/11/06/mobile-es5-compatiable/">
                            <h3 class="media-heading">모바일 브라우저 ECMAScript5 지원 현황</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Nov 6, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2013/12/05/animation-for-performance/">
                            <h3 class="media-heading">애니메이션 성능을 높이는 방법</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Dec 5, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2014/11/19/How-to-make-a-smooth-animation/">
                            <h3 class="media-heading">How to Make a Smooth Animation</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Nov 19, 2014
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2015/01/16/angular1-for-performance/">
                            <h3 class="media-heading">AngularJS 성능 이슈에 대한 이야기</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 16, 2015
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2015/09/03/Ftp-settings-in-OSX/">
                            <h3 class="media-heading">Anonymous FTP Settings in OSX</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Sep 3, 2015
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://sculove.github.io/blog/2015/09/03/Apache2-settings-in-OSX/">
                            <h3 class="media-heading">Apache2 Settings in OSX</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Sep 3, 2015
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium" data-message-zero="no post found" data-message-one="1 post found" data-message-other="{n} posts found">
                67 posts found
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/blog/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/blog/assets/js/jquery.js"></script>
<script src="/blog/assets/js/jquery.fancybox.js"></script>
<script src="/blog/assets/js/thumbs.js"></script>
<script src="/blog/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script>
    <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
    <script>
        var algoliaClient = algoliasearch('0E46FZ0JA2', '01370395a4f67d606d12d489c615c822');
        var algoliaIndex = algoliaClient.initIndex('sculove.github.io');
    </script>


    </body>
</html>
